#!/bin/sh

# Script by www.seguridadwireless.net

SCRIPT_VERSION=20160217

############################################################
## Funciones comunes. Su nombre empieza por f_ ##
############################################################
f_variables(){
	. /opt/wifislax-updaters/Funciones/funciones_updater
}

############################################################
## Funciones propias del script. Su nombre empieza por F_ ##
############################################################
# Definicion de variables
F_variables() {
	WEB=https://sourceforge.net/projects/libquicktime/files/
	VERSION=`curl -s $WEB | grep /latest | cut -d '/' -f 8 | cut -d ":" -f 1 | cut -d '-' -f 2 | cut -d "t" -f-1`
	PRGNAM=libquicktime
	echo -ne "\033]2;${PRGNAM}_updater\007"
	EXTENSION=tar.gz
	SOURCES=$PRGNAM-$VERSION.$EXTENSION
	DOWNLOAD=$WEB/$SOURCES
}

# Descomprimimos el fichero descargado y compilamos
F_compilar(){ 
# Generamos parche y aplicamos
if [ $VERSION = "1.2.4" ]; then
cat > libquicktime-1.2.4-ffmpeg2.patch << "EOF"
Extracted from upstream CVS.
https://bugs.gentoo.org/show_bug.cgi?id=476498

Index: libquicktime-1.2.4/plugins/ffmpeg/audio.c
===================================================================
--- libquicktime-1.2.4.orig/plugins/ffmpeg/audio.c
+++ libquicktime-1.2.4/plugins/ffmpeg/audio.c
@@ -45,6 +45,11 @@
 #define ENCODE_AUDIO 1
 #endif
 
+#ifndef AVCODEC_MAX_AUDIO_FRAME_SIZE
+/* from libavcodec/avcodec.h dated Dec 23 2012 */
+#define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
+#endif
+
 /* The following code was ported from gmerlin_avdecoder (http://gmerlin.sourceforge.net) */
 
 /* MPEG Audio header parsing code */
Index: libquicktime-1.2.4/plugins/ffmpeg/params.c
===================================================================
--- libquicktime-1.2.4.orig/plugins/ffmpeg/params.c
+++ libquicktime-1.2.4/plugins/ffmpeg/params.c
@@ -101,6 +101,17 @@ typedef struct
     }                                           \
   }
 
+#define PARAM_DICT_INT(name, dict_name)             \
+  {                                                 \
+  if(!strcasecmp(name, key))                        \
+    {                                               \
+    char buf[128];                                  \
+    snprintf(buf, sizeof(buf), "%d", *(int*)value); \
+    av_dict_set(options, dict_name, buf, 0);        \
+    found = 1;                                      \
+    }                                               \
+  }
+
 #define PARAM_DICT_FLAG(name, dict_name)        \
   {                                             \
   if(!strcasecmp(name, key))                    \
@@ -202,8 +213,15 @@ void lqt_ffmpeg_set_parameter(AVCodecCon
   PARAM_INT("ff_max_b_frames",max_b_frames);
   PARAM_FLOAT("ff_b_quant_factor",b_quant_factor);
   PARAM_INT("ff_b_frame_strategy",b_frame_strategy);
+
+#if LIBAVCODEC_VERSION_MAJOR >= 55
+  PARAM_DICT_INT("ff_luma_elim_threshold","luma_elim_threshold");
+  PARAM_DICT_INT("ff_chroma_elim_threshold","chroma_elim_threshold");
+#else
   PARAM_INT("ff_luma_elim_threshold",luma_elim_threshold);
   PARAM_INT("ff_chroma_elim_threshold",chroma_elim_threshold);
+#endif
+
   PARAM_INT("ff_strict_std_compliance",strict_std_compliance);
   PARAM_QP2LAMBDA("ff_b_quant_offset",b_quant_offset);
   PARAM_INT("ff_rc_min_rate",rc_min_rate);
@@ -241,8 +259,15 @@ void lqt_ffmpeg_set_parameter(AVCodecCon
   PARAM_QP2LAMBDA("ff_lmax", lmax);
   PARAM_INT("ff_noise_reduction",noise_reduction);
   PARAM_INT_SCALE("ff_rc_initial_buffer_occupancy",rc_initial_buffer_occupancy,1000);
+
+#if LIBAVCODEC_VERSION_MAJOR >= 55
+  PARAM_DICT_INT("ff_inter_threshold","inter_threshold");
+  PARAM_DICT_INT("ff_quantizer_noise_shaping","quantizer_noise_shaping");
+#else
   PARAM_INT("ff_inter_threshold",inter_threshold);
   PARAM_INT("ff_quantizer_noise_shaping",quantizer_noise_shaping);
+#endif
+
   PARAM_INT("ff_thread_count",thread_count);
   PARAM_INT("ff_me_threshold",me_threshold);
   PARAM_INT("ff_mb_threshold",mb_threshold);
@@ -272,8 +297,16 @@ void lqt_ffmpeg_set_parameter(AVCodecCon
   PARAM_FLAG("ff_flag_bitexact",CODEC_FLAG_BITEXACT);
   PARAM_FLAG("ff_flag_ac_pred",CODEC_FLAG_AC_PRED);
   //  PARAM_FLAG("ff_flag_h263p_umv",CODEC_FLAG_H263P_UMV); // Unused
+
+#if LIBAVCODEC_VERSION_MAJOR >= 55
+  PARAM_DICT_FLAG("ff_flag_cbp_rd","cbp_rd");
+  PARAM_DICT_FLAG("ff_flag_qp_rd","qp_rd");
+  PARAM_DICT_FLAG("ff_flag2_strict_gop","strict_gop");
+#else
   PARAM_FLAG("ff_flag_cbp_rd",CODEC_FLAG_CBP_RD);
   PARAM_FLAG("ff_flag_qp_rd",CODEC_FLAG_QP_RD);
+  PARAM_FLAG2("ff_flag2_strict_gop",CODEC_FLAG2_STRICT_GOP);
+#endif
 
 #if LIBAVCODEC_VERSION_MAJOR >= 54
   PARAM_DICT_FLAG("ff_flag_h263p_aiv", "aiv");
@@ -288,7 +321,6 @@ void lqt_ffmpeg_set_parameter(AVCodecCon
   PARAM_FLAG("ff_flag_loop_filter",CODEC_FLAG_LOOP_FILTER);
   PARAM_FLAG("ff_flag_closed_gop",CODEC_FLAG_CLOSED_GOP);
   PARAM_FLAG2("ff_flag2_fast",CODEC_FLAG2_FAST);
-  PARAM_FLAG2("ff_flag2_strict_gop",CODEC_FLAG2_STRICT_GOP);
   PARAM_ENUM("ff_coder_type",coder_type,coder_type);
   
   }

EOF
# Aplicamos parche
patch -p1 < libquicktime-1.2.4-ffmpeg2.patch
fi

 
# Configuramos paquete
echo ""
echo "$VERDE"Configurando ..."$CIERRE"
sleep 1
CFLAGS="$SLKCFLAGS" \
CXXFLAGS="$SLKCFLAGS" \
./configure \
  --prefix=/usr \
  --with-ffmpeg \
  --with-x264 \
  --without-doxygen \
  --enable-gpl \
  --with-libdv \
  --build=$ARCH-slackware-linux
  
# Compilamos paquete
echo ""
echo "$VERDE"Compilando ..."$CIERRE"
sleep 1
make  || exit 1
make install-strip DESTDIR=$PKG
}

###################################
## BLOQUE PRINCIPAL DE EJECUCION ##
###################################
# Si se cierra el script inesperadamente, ejecutar la funcion de limpieza
trap f_exitmode SIGHUP SIGINT

#Inicializamos las variables globales
f_variables
#Comprobamos conexion a Internet
f_comprobarConexion
#Inicializamos las variables del script
F_variables
#Creamos directorio de trabajo
f_directorioTemporal
#Mostramos el mensaje de presentacion
f_presentacion
#Comprobamos updates del script
f_comprobarUpdates
#Asignamos o detectamos arquitectura
f_arquitectura
#Comprobamos version instalada del script
f_versionInstalada
#Si no existe el fichero se descargara
f_download
#Preparamos entorno
f_preparar
#Descomprimir fichero descargado y compilamos
F_compilar
#Creamos xzm , instalamos y salimos
f_tareasFinales